.version 7.0
.target sm_70
.address_size 64

// Dependent chain: result of each FMA feeds the next.
// Each lane stalls until previous FMA completes.
.entry dependent_chain(
    .param .u64 _ptrA, .param .u64 _ptrB, .param .u64 _ptrOut)
{
    .reg .f32  %f<6>;           // %f0-%f5
    .reg .b64  %rd<6>;
    ld.param.u64 %rd1, [_ptrA]; // load pointers
    ld.param.u64 %rd2, [_ptrB];
    ld.param.u64 %rd3, [_ptrOut];
    ld.global.f32 %f1, [%rd1];  // load a
    ld.global.f32 %f2, [%rd2];  // load b
    mov.f32 %f3, 1.0;           // scalar coefficient
    // Strict chain: each op depends on previous %fX
    fma.rn.f32 %f4, %f1, %f2, %f3; // %f4 = a*b + 1
    fma.rn.f32 %f4, %f4, %f2, %f3; // dependent on %f4
    fma.rn.f32 %f4, %f4, %f2, %f3; // chain grows
    st.global.f32 [%rd3], %f4;
    ret;
}

// Independent accumulators: 4 chains in parallel,
// exposing ILP to the FMA pipeline at cost of more regs.
.entry independent_accum(
    .param .u64 _ptrA, .param .u64 _ptrB, .param .u64 _ptrOut)
{
    .reg .f32  %fa<10>;         // %fa0-%fa9
    .reg .b64  %rd<6>;
    ld.param.u64 %rd1, [_ptrA];
    ld.param.u64 %rd2, [_ptrB];
    ld.param.u64 %rd3, [_ptrOut];
    // load 4 values per lane (example pattern)
    ld.global.f32 %fa0, [%rd1]; ld.global.f32 %fa1, [%rd2];
    ld.global.f32 %fa2, [%rd1+4]; ld.global.f32 %fa3, [%rd2+4];
    // 4 independent accumulators
    fma.rn.f32 %fa4, %fa0, %fa1, 1.0; // acc0
    fma.rn.f32 %fa5, %fa2, %fa3, 1.0; // acc1
    fma.rn.f32 %fa6, %fa0, %fa1, %fa4; // uses acc0 but overlaps
    fma.rn.f32 %fa7, %fa2, %fa3, %fa5; // uses acc1 but overlaps
    // store result of combining accumulators
    add.f32 %fa8, %fa6, %fa7;
    st.global.f32 [%rd3], %fa8;
    ret;
}