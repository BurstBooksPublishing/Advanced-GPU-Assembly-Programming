extern "C" __global__
void dot_product_kernel(const float* __restrict__ a, const float* __restrict__ b,
                        float* __restrict__ out, int N) {
  // compute global thread index
  int gid = blockIdx.x * blockDim.x + threadIdx.x;
  float sum = 0.0f;
  // Stride loop to cover large N; uses __ldg for read-only cache (Pascal beneficial).
  for (int i = gid; i < N; i += gridDim.x * blockDim.x) {
    float va = __ldg(&a[i]); // read-only cache
    float vb = __ldg(&b[i]);
    sum += va * vb;
  }
  // warp-level reduction using shuffle down (works for SMs with shuffle support).
  for (int offset = 16; offset > 0; offset >>= 1)
    sum += __shfl_down_sync(0xFFFFFFFFu, sum, offset);
  // one lane writes per warp
  if ((threadIdx.x & 31) == 0) atomicAdd(out, sum); // atomicAdd is FP32 safe on Pascal
}